# Functional Description - Bit-Serial Bus System

## Overview

The bit-serial bus system implements a shared communication infrastructure for 2 masters and 3 slave memories, transmitting data sequentially (one bit at a time) over a 4-wire serial interface. This design minimizes interconnect wiring compared to parallel buses while maintaining support for priority-based arbitration and split transactions.

## Serial Protocol

### Frame Format

Each transaction consists of a 27-bit serial frame transmitted MSB-first:

```
+-------+-----+--------------+-----------+--------+------+
| START | CMD | ADDR[13:0]   | DATA[7:0] | PARITY | STOP |
| 1 bit | 2b  | 14 bits      | 8 bits    | 1 bit  | 1 bit|
+-------+-----+--------------+-----------+--------+------+
         Total: 27 bits per transaction
```

**Field Definitions:**

- **START** (1 bit): Transaction delimiter, always `1`
- **CMD** (2 bits):
  - `2'b00`: READ - Request data from slave
  - `2'b01`: WRITE - Write data to slave
  - `2'b10`: SPLIT_START - Slave not ready (future use)
  - `2'b11`: SPLIT_CONTINUE - Slave data ready (future use)
- **ADDR** (14 bits): Memory address (supports up to 16KB address space)
- **DATA** (8 bits): Write data (master to slave) or read response (slave to master)
- **PARITY** (1 bit): Even parity over CMD + ADDR + DATA fields
- **STOP** (1 bit): Transaction delimiter, always `1`

### Timing Characteristics

- **Serial Clock (SCLK)**: Generated by dividing system clock by 4
  - System clock: 50 MHz
  - Serial clock: 12.5 MHz
  - Bit period: 4 system clock cycles (80 ns)
- **Frame Duration**: 27 bits × 80 ns = 2.16 µs per transaction
- **Sampling**: Data sampled on rising edge of SCLK
- **Clock Generation**: 2-bit counter creates SCLK with 50% duty cycle

### 4-Wire Serial Interface

```
Signal     | Direction      | Description
-----------|----------------|----------------------------------
sdata      | Bidirectional  | Serial data (request/response)
sclk       | Master → Slave | Serial clock (12.5 MHz)
svalid     | Master → Slave | Transaction valid indicator
sready     | Slave → Master | Slave ready for new transaction
```

## Module Descriptions

### 1. Serializer (`serializer.sv`)

**Purpose**: Converts parallel frame structure to serial bitstream

**Operation**:
1. **Frame Load**: On `start_i` pulse, loads 27-bit frame into shift register
2. **Clock Generation**: 2-bit divider creates SCLK (system_clk / 4)
   - SCLK = 1 when `clk_div_q == 2'd1`
   - SCLK = 0 when `clk_div_q == 2'd3`
3. **Serialization**: Shifts MSB out on `sdata_o` every 4 system clocks
4. **Bit Counter**: Tracks bits transmitted (0 to 26)
5. **Completion**: Asserts `done_o` pulse after 27th bit

**Key Features**:
- Non-blocking: Accepts new frame when `busy_o == 0`
- Self-timed: Generates own SCLK aligned to bit transmission
- MSB-first: Transmits frame[26] first, frame[0] last

### 2. Deserializer (`deserializer.sv`)

**Purpose**: Converts serial bitstream to parallel frame structure

**Operation**:
1. **Start Detection**: Monitors `sdata_i` for START bit (`1`) when `svalid_i` asserted
2. **Edge Detection**: 2-FF synchronizer creates `sclk_posedge` pulse
3. **Shift-In**: Samples `sdata_i` on rising SCLK edge, shifts into LSB position
4. **Bit Counter**: Increments on each SCLK edge (0 to 26)
5. **Frame Assembly**: After 27 bits, asserts `frame_valid_o` pulse
6. **Parity Check**: Compares received parity against calculated value

**Key Features**:
- Frame validation: Checks START, STOP, and parity bits
- Error detection: Asserts `parity_err_o` if parity mismatch
- LSB shift: Builds frame from MSB to LSB order

### 3. TX Controller (`tx_controller.sv`)

**Purpose**: Manages master-side transaction flow and handshaking

**State Machine**:

```
TX_IDLE:
  - Assert ready_o when idle and not latched
  - On valid_i rising edge: latch request, goto TX_BUILD
  - Clear latch when valid_i returns LOW

TX_BUILD:
  - Construct serial_frame_t from parallel inputs
  - Set START=1, CMD (based on we_i), ADDR, DATA
  - Calculate even parity over CMD+ADDR+DATA
  - Set STOP=1
  - Goto TX_SEND

TX_SEND:
  - Assert ser_start_o (triggers serializer)
  - When ser_busy_i asserts: goto TX_WAIT

TX_WAIT:
  - Wait for trans_complete_i
  - On completion: assert ready_o, goto TX_IDLE
  - Abort if valid_i de-asserted
```

**Handshaking Protocol**:
- **Request Latch**: Prevents double-triggering on held `valid_i`
- **Completion Hold**: Keeps `ready_o` asserted for 1 cycle after completion
- **Abort Handling**: Returns to IDLE if master de-asserts `valid_i` during wait

### 4. Frame Decoder (`frame_decoder.sv`)

**Purpose**: Validates and decodes received frames into parallel control signals

**State Machine**:

```
DEC_IDLE:
  - Wait for frame_valid_i
  - On frame arrival: perform validation checks
  - If valid: decode fields, assert valid_o, goto DEC_DECODE
  - If error: assert err_o only

DEC_DECODE:
  - Hold decoded outputs for 1 cycle
  - Return to DEC_IDLE
```

**Validation Checks**:
1. **Parity**: Compare `frame_i.parity` vs. calculated even parity
2. **START bit**: Must be `1`
3. **STOP bit**: Must be `1`

**Error Handling**:
- Sets `err_o = 1` if any validation fails
- Sets `valid_o = 0` on error (no spurious bus activity)

**Decoding**:
- `addr_o` = frame_i.addr (14 bits)
- `wdata_o` = frame_i.data (8 bits)
- `we_o` = 1 if CMD == WRITE or SPLIT_START

### 5. Parallel-to-Serial Adapter (`parallel_to_serial.sv`)

**Purpose**: Master-side bridge between parallel bus masters and serial interface

**Components**:
- **TX Controller**: Manages request handshaking
- **Serializer**: Transmits request frames
- **Deserializer**: Receives response frames (for READs)

**Operation**:

**WRITE Transactions**:
1. Master asserts `valid_i`, `addr_i`, `wdata_i`, `we_i=1`
2. TX controller builds WRITE frame
3. Serializer transmits 27-bit frame on `sdata_o`
4. On `ser_done` pulse: `trans_complete` asserted
5. TX controller asserts `ready_o` (completes handshake)

**READ Transactions**:
1. Master asserts `valid_i`, `addr_i`, `we_i=0`
2. TX controller builds READ frame
3. Serializer transmits request
4. Module sets `waiting_response_q = 1`
5. Deserializer captures response frame on `sdata_i`
6. On `deser_frame_valid`: `trans_complete` asserted
7. `rdata_o` = response frame data
8. TX controller asserts `ready_o`

**Key Signals**:
- `trans_complete`: Asserted when WRITE done OR READ response received
- `waiting_response_q`: Delays `ready_o` until response arrives
- `svalid_o`: Asserted during frame transmission (tied to `ser_busy`)

### 6. Serial-to-Parallel Adapter (`serial_to_parallel.sv`)

**Purpose**: Slave-side bridge between serial interface and parallel bus slaves

**Components**:
- **Deserializer**: Receives request frames
- **Frame Decoder**: Validates and decodes frames
- **Response Serializer**: Transmits READ responses

**Operation**:

**WRITE Transactions**:
1. Deserializer captures incoming frame
2. Frame decoder validates and outputs `valid_o`, `addr_o`, `wdata_o`, `we_o=1`
3. Slave processes write (via parallel interface)
4. No response required

**READ Transactions**:
1. Deserializer captures READ frame (`dec_we=0`)
2. Frame decoder outputs `valid_o`, `addr_o`
3. Response FSM transitions to `RESP_WAIT_SLAVE`
4. Waits for slave `ready_i` assertion (data available)
5. Builds response frame: CMD=READ, ADDR=saved, DATA=rdata_i
6. Response serializer transmits 27-bit response

**Response State Machine**:

```
RESP_IDLE:
  - Detect READ: dec_valid && !dec_we
  - Save addr_o to read_addr_q
  - If ready_i already high: start response immediately
  - Else: goto RESP_WAIT_SLAVE

RESP_WAIT_SLAVE:
  - Wait for ready_i (slave data ready)
  - Start response serializer
  - Goto RESP_SENDING

RESP_SENDING:
  - Wait for resp_done
  - Return to RESP_IDLE
```

**Error Signaling**:
- If `err_i` asserted by slave: response CMD set to WRITE (error indicator)
- Master detects error if response CMD != READ

### 7. Serial Arbiter (`serial_arbiter.sv`)

**Purpose**: Priority-based arbitration with frame-atomic grants

**State Machine**:

```
ARB_IDLE:
  - No active transaction
  - If req_i[0]: grant to Master 0, goto ARB_MASTER0
  - Else if req_i[1]: grant to Master 1, goto ARB_MASTER1
  - If split_pending: goto ARB_SPLIT (preempts new requests)

ARB_MASTER0:
  - Master 0 owns bus
  - gnt_o = 2'b01, msel_o = 0
  - Hold grant while frame_active_i (27-bit frame in progress)
  - When frame_active_i deasserts AND req_i[0] low: return to ARB_IDLE

ARB_MASTER1:
  - Master 1 owns bus
  - gnt_o = 2'b10, msel_o = 1
  - Hold grant while frame_active_i
  - When frame_active_i deasserts AND req_i[1] low: return to ARB_IDLE

ARB_SPLIT:
  - Split transaction owner regains bus
  - gnt_o/msel_o set per split_owner_q
  - Clear when split_pending deasserts
```

**Priority Policy**:
1. **Split Transactions**: Highest priority (preempts new requests)
2. **Master 0**: Second priority
3. **Master 1**: Lowest priority

**Frame-Atomic Grants**:
- Grant held constant during entire 27-bit frame transmission
- `frame_active_i` signal prevents mid-frame arbitration
- New arbitration only when frame completes AND requester releases

### 8. Address Decoder (`addr_decoder.sv`)

**Purpose**: Routes transactions to appropriate slave based on address

**Address Map**:

```
Slave  | Address Range       | Size | Split Capable
-------|---------------------|------|---------------
Slave0 | 0x0000 - 0x0FFF     | 4KB  | Yes
Slave1 | 0x1000 - 0x1FFF     | 4KB  | No
Slave2 | 0x2000 - 0x27FF     | 2KB  | No
```

**Decoding Logic**:
- **Slave0**: `addr_i[13:12] == 2'b00`
- **Slave1**: `addr_i[13:12] == 2'b01`
- **Slave2**: `addr_i[13:11] == 3'b100`
- **No match**: Assert `err_o`

**Operation**:
1. Receives `valid_i`, `addr_i`, `wdata_i`, `we_i` from serial-to-parallel adapter
2. Activates one of `slave_valid_o[2:0]` based on address
3. Forwards `addr_i`, `wdata_i`, `we_i` to selected slave
4. Multiplexes `slave_rdata_i`, `slave_ready_i` back to adapter
5. Asserts `err_o` if address out of range

### 9. Slave Memory (`slave_mem.sv`)

**Purpose**: Simple SRAM-based slave for demonstration and testing

**Operation**:
- **WRITE**: On `valid_i && we_i`: `mem[addr_i] <= wdata_i`
- **READ**: On `valid_i && !we_i`: `rdata_o <= mem[addr_i]`
- **Ready**: Asserts `ready_o` combinationally (single-cycle response)
- **No Split Support**: Always ready (except Slave0 can be configured for splits)

**Memory Sizes**:
- Slave0: 4096 bytes (12-bit address)
- Slave1: 4096 bytes (12-bit address)
- Slave2: 2048 bytes (11-bit address)

### 10. Top-Level Integration (`bitserial_top.sv`)

**Purpose**: Complete system integration with 2 masters, 3 slaves, arbiter, and serial bus

**System Architecture**:

```
[Master0] ---|
             |---> [P2S Adapter] ---> [Arbiter] ---> [S2P Adapter] ---> [Addr Decoder] ---> [Slave0]
[Master1] ---|                                                      |                 |--> [Slave1]
                                                                    |                 |--> [Slave2]
                                                                    |
                                                                    <-- Response Path --
```

**Signal Flow**:

**Master to Serial Bus**:
1. Masters assert `valid_i`, `addr_i`, `wdata_i`, `we_i`
2. P2S adapters serialize requests
3. Arbiter grants one master based on priority
4. Selected `sdata/sclk/svalid` routed to S2P adapter

**Serial Bus to Slaves**:
1. S2P adapter deserializes frame
2. Frame decoder validates and decodes
3. Address decoder routes to appropriate slave
4. Slave processes transaction

**Response Path (READs)**:
1. Slave provides `rdata_i`, `ready_i`
2. S2P adapter builds response frame
3. Response serializer transmits on `sdata_o`
4. P2S adapter deserializer captures response
5. Master receives `rdata_o`, `ready_o`

## Error Handling

### Parity Errors
- **Detection**: Deserializer compares received parity vs. calculated
- **Response**: Frame decoder asserts `err_o`, sets `valid_o=0`
- **Master Impact**: `err_o` propagated to master; transaction aborted

### Frame Errors
- **Missing START**: Deserializer ignores frame (no `frame_valid_o`)
- **Missing STOP**: Frame decoder asserts `err_o`

### Address Errors
- **Out of Range**: Address decoder asserts `err_o`
- **Response**: S2P adapter sends error response (CMD=WRITE for READ requests)

### Split Transaction Errors
- **Not Implemented**: Current design does not exercise split path
- **Framework Present**: Arbiter supports `split_pending` signal for future use

## Performance Characteristics

### Latency
- **WRITE Transaction**: ~2.2 µs (27 bits + arbitration + decode)
- **READ Transaction**: ~4.4 µs (request + response frames)
- **Arbitration Delay**: 0 cycles (combinational grant from next state)

### Throughput
- **Peak Rate**: 460 KB/s (12.5 MHz / 27 bits/frame × 8 bits/byte)
- **Effective Rate**: ~227 KB/s (accounting for read round-trips)

### Resource Utilization (Estimated)
- **Logic Elements**: ~2500-3500 LEs (target < 20% of 22,320 on EP4CE22F17C6)
- **Shift Registers**: 27-bit × 4 (serializers/deserializers)
- **State Machines**: 5 FSMs (TX ctrl, frame decoder, arbiter, 2× response ctrl)
- **Memory**: 10 KB SRAM (Slave0: 4KB, Slave1: 4KB, Slave2: 2KB)

## Clock Domain Considerations

**Single Clock Domain**:
- All modules operate on common `clk_i` (50 MHz system clock)
- Serial clock (SCLK) is derived, not independent
- No CDC required for intra-board communication

**Future Inter-Board Extension**:
- GPIO pins for inter-board link will require:
  - 2-FF synchronizers for `sdata_i`, `svalid_i`
  - Handshake protocol for flow control
  - Potential FIFO buffering for clock domain crossing

## Compliance with lowRISC Verilog Style

All modules follow the lowRISC coding guidelines:

- **Naming**: Snake_case for signals, `_i`/`_o` suffixes for ports
- **Reset**: Async active-low `rst_ni`, synchronous in flops
- **Clocking**: Single posedge `clk_i`, no negedge clocks
- **FSMs**: Explicit `_d` (next) and `_q` (current) state registers
- **Combinational**: `always_comb` blocks with default assignments
- **Sequential**: `always_ff` blocks, no latches
- **Packages**: Centralized parameters and types in `bus_pkg.sv`
